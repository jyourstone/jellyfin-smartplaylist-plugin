<!DOCTYPE html>
<html>
<head>
    <title>Smart Playlist</title>
    <style>
        .SmartPlaylistConfigurationPage .readOnly, .SmartPlaylistConfigurationPage .readOnly-multiline {
            background: #101010;
        }

        .SmartPlaylistConfigurationPage .ui-tabs-nav.emby-tabs {
            margin-top: 2em;
        }

        .playlist-card {
            border: 1px solid #444;
            padding: 1em;
            border-radius: 4px;
            margin-bottom: 2em;
        }

        .playlist-title {
            margin-top: 0;
        }

        .playlist-rule {
            font-family: monospace;
            background: rgba(255,255,255,0.1);
            padding: 2px 4px;
            border-radius: 2px;
        }

        .playlist-actions {
            margin-top: 1em;
        }

        .error-message {
            color: #ff6b6b;
        }

        /* Custom Modal Styles */
        body .SmartPlaylistConfigurationPage .custom-modal {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: rgba(0,0,0,0.75) !important;
            z-index: 10000 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }
        body .SmartPlaylistConfigurationPage .custom-modal.hide {
            display: none !important;
        }
        body .SmartPlaylistConfigurationPage #delete-confirm-modal .custom-modal-container {
            background-color: #2a2a2a !important;
            color: #eee !important;
            border: 1px solid #555 !important;
            border-radius: 8px !important;
            padding: 1.5em !important;
            width: 90% !important;
            max-width: 400px !important;
            box-shadow: 0 8px 32px rgba(0,0,0,0.8) !important;
            z-index: 10001 !important;
            position: relative !important;
        }
        .custom-modal-header .custom-modal-title {
            margin: 0;
            font-size: 1.25em;
        }
        .custom-modal-body {
            margin: 1em 0;
        }
        .custom-modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 1em;
        }
        .custom-modal-footer .button-submit {
            background-color: #d9534f;
        }
        
        .logic-separator {
            text-align: center;
            margin: 0.75em 0;
            font-weight: bold;
            color: #888;
            font-size: 0.9em;
            background: rgba(136, 136, 136, 0.1);
            padding: 0.25em;
            border-radius: 4px;
            display: inline-block;
            min-width: 40px;
        }
        
        .SmartPlaylistConfigurationPage .logic-group {
            border: 2px solid #00a4dc !important;
            border-radius: 8px !important;
            padding: 1.5em !important;
            margin-bottom: 2em !important;
            background: rgba(0, 164, 220, 0.08) !important;
            box-shadow: 0 2px 8px rgba(0, 164, 220, 0.15) !important;
            position: relative !important;
        }
        
        .SmartPlaylistConfigurationPage .logic-group::before {
            content: 'AND Group' !important;
            position: absolute !important;
            top: -0.6em !important;
            left: 1em !important;
            background: #1a1a1a !important;
            color: #00a4dc !important;
            padding: 0.2em 0.8em !important;
            border-radius: 4px !important;
            font-size: 0.75em !important;
            font-weight: bold !important;
            border: 1px solid #00a4dc !important;
        }
        
        .SmartPlaylistConfigurationPage .logic-group-separator {
            text-align: center !important;
            margin: 2.5em 0 !important;
            position: relative !important;
        }
        
        .SmartPlaylistConfigurationPage .logic-group-separator::before {
            content: '' !important;
            position: absolute !important;
            top: 50% !important;
            left: 0 !important;
            right: 0 !important;
            height: 2px !important;
            background: linear-gradient(to right, transparent, #ff6b6b, transparent) !important;
            z-index: 1 !important;
        }
        
        .SmartPlaylistConfigurationPage .logic-group-separator-text {
            background: #1a1a1a !important;
            color: #ff6b6b !important;
            padding: 0.8em 1.5em !important;
            border-radius: 6px !important;
            font-weight: bold !important;
            font-size: 1em !important;
            position: relative !important;
            z-index: 2 !important;
            display: inline-block !important;
            border: 2px solid #ff6b6b !important;
            box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3) !important;
        }
        
        .rule-actions {
            display: flex;
            gap: 0.5em;
            align-items: center;
            margin-left: 0.5em;
        }
        
        .rule-action-btn.hidden {
            display: none !important;
        }
        
        .SmartPlaylistConfigurationPage .rule-within-group-separator {
            text-align: center !important;
            margin: 0.8em 0 !important;
            color: #00a4dc !important;
            font-size: 0.8em !important;
            font-weight: bold !important;
            position: relative !important;
            padding: 0.3em 0 !important;
        }
        
        .SmartPlaylistConfigurationPage .rule-within-group-separator::before {
            content: '' !important;
            position: absolute !important;
            top: 50% !important;
            left: 20% !important;
            right: 20% !important;
            height: 1px !important;
            background: rgba(0, 164, 220, 0.3) !important;
            z-index: 1 !important;
        }
        


        .media-type-flex {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5em;
            align-items: center;
        }
    </style>
</head>
<body>
    <div data-role="page" class="page type-interior pluginConfigurationPage SmartPlaylistConfigurationPage">
        <div data-role="content">
            <div class="content-primary">
                <h1>SmartPlaylist Configuration</h1>
                <div id="plugin-notification-area" style="display: none; padding: 1em; margin: 1em 0; border-radius: 4px; text-align: center; font-weight: bold;"></div>

                <div class="emby-tabs">
                    <div class="emby-tab-button" data-tab="create">
                        <h3 class="emby-tab-button-title">Create Playlist</h3>
                    </div>
                    <div class="emby-tab-button" data-tab="manage">
                        <h3 class="emby-tab-button-title">Manage Playlists</h3>
                    </div>
                     <div class="emby-tab-button" data-tab="settings">
                        <h3 class="emby-tab-button-title">Settings</h3>
                    </div>
                     <div class="emby-tab-button" data-tab="help">
                        <h3 class="emby-tab-button-title">Help</h3>
                    </div>
                </div>

                <h2 class="section-title" id="current-tab-title">Create Playlist</h2>
                <div id="edit-mode-indicator" style="display: none; color: #ffa500; font-weight: bold; margin: 0.5em 0;">
                    <span>✏️ Editing Mode - Modifying existing playlist</span>
                    <button type="button" id="cancelEditBtn" class="emby-button raised" style="margin-left: 1em; font-size: 0.8em;">Cancel Edit</button>
                </div>

                <!-- Create Tab -->
                <div id="create-tab" class="page-content hide" data-tab-content="create">
                    <form id="playlistForm" style="margin-top:2em;">
                        <div class="input-container" style="margin-bottom: 1em;">
                            <label class="input-label" for="playlistName">Playlist Name</label>
                            <input type="text" id="playlistName" class="emby-input" required placeholder="e.g., 90s Action Movies">
                        </div>
                       
                        <div class="input-container" style="margin-bottom: 1em;">
                            <label class="input-label">Media Types</label>
                            <div class="field-description">Select one or more media types to include. This filter is always applied first.</div>
                            <div class="media-type-flex" style="margin-top: 0.5em;">
                                <label class="checkbox-label">
                                    <input type="checkbox" is="emby-checkbox" id="mediaTypeMovie" class="emby-checkbox media-type-checkbox" value="Movie">
                                    <span>Movies</span>
                                </label>
                                <label class="checkbox-label">
                                    <input type="checkbox" is="emby-checkbox" id="mediaTypeEpisode" class="emby-checkbox media-type-checkbox" value="Episode">
                                    <span>TV Shows</span>
                                </label>
                                <label class="checkbox-label">
                                    <input type="checkbox" is="emby-checkbox" id="mediaTypeAudio" class="emby-checkbox media-type-checkbox" value="Audio">
                                    <span>Music</span>
                                </label>
                            </div>
                        </div>

                        <div class="input-container">
                            <label class="input-label">Rules</label>
                            <div class="field-description" style="margin-bottom: 1em;">Build your rules using logical groups. Rules within a group are combined with AND, groups are combined with OR.</div>
                            <div id="rules-container"></div>
                        </div>

                        <div class="input-container" style="margin-bottom: 1em; margin-top: 1em;">
                            <label class="input-label" for="sortBy">Sort By</label>
                            <div id="sortBy-container"></div>
                        </div>

                        <div class="input-container" style="margin-bottom: 1em; margin-top: 1em;">
                            <label class="input-label" for="sortOrder">Sort Order</label>
                            <div id="sortOrder-container"></div>
                        </div>

                        <div class="input-container" style="margin-bottom: 1em;">
                            <label class="input-label" for="playlistUser">Playlist Owner</label>
                            <select is="emby-select" id="playlistUser" class="emby-select" required>
                                <option value="">Loading users...</option>
                            </select>
                            <div class="field-description">The user who this playlist belongs to.</div>
                        </div>

                        <div class="checkbox-container" style="margin-bottom: 1em; margin-top: 1em;">
                            <label class="checkbox-label">
                                <input type="checkbox" is="emby-checkbox" id="playlistIsPublic" class="emby-checkbox">
                                <span>Make playlist public</span>
                            </label>
                            <div class="field-description">Allow this playlist to be viewed by any logged in user.</div>
                        </div>

                        <div style="margin-top: 2em;">
                            <button type="submit" id="submitBtn" class="button-submit emby-button block">Create Playlist</button>
                            <button type="button" id="clearFormBtn" class="emby-button raised block">Clear Form</button>
                        </div>
                    </form>
                </div>

                <!-- Manage Tab -->
                <div id="manage-tab" class="page-content hide" data-tab-content="manage">
                    <div style="margin-top:2em;">
                        <div class="input-container">
                            <button type="button" is="emby-button" id="refreshPlaylistListBtn" class="emby-button raised">Refresh List</button>
                        </div>
                        
                        <div id="playlist-list-container">
                            <p>Loading playlists...</p>
                        </div>
                    </div>
                </div>

                <!-- Settings Tab -->
                <div id="settings-tab" class="page-content hide" data-tab-content="settings">
                    <div style="margin-top:2em;">
                        <h3 class="section-title">General Settings</h3>
                        <div class="input-group" style="display: flex; gap: 2em;">
                            <div class="input-container flex-grow">
                                <label class="input-label" for="defaultSortBy">Default Sort By</label>
                                <select is="emby-select" id="defaultSortBy" class="emby-select"></select>
                                <div class="field-description">Default sorting method for new smart playlists.</div>
                            </div>
                            <div class="input-container flex-grow">
                                <label class="input-label" for="defaultSortOrder">Default Sort Order</label>
                                <select is="emby-select" id="defaultSortOrder" class="emby-select"></select>
                                <div class="field-description">Default sorting direction for new smart playlists.</div>
                            </div>
                        </div>

                        <div class="checkbox-container" style="margin-bottom: 1em; margin-top: 1em;">
                            <label class="checkbox-label">
                                <input type="checkbox" is="emby-checkbox" id="defaultMakePublic" class="emby-checkbox">
                                <span>Make playlists public by default</span>
                            </label>
                            <div class="field-description">New smart playlists will be public by default when this is enabled.</div>
                        </div>

                        <div style="margin-top: 2em;">
                            <button type="button" is="emby-button" id="saveSettingsBtn" class="button-submit emby-button block">Save Settings</button>
                            <button type="button" is="emby-button" id="refreshPlaylistsBtn" class="emby-button raised block" style="margin-top: 0.5em;">Refresh All Playlists</button>
                        </div>
                    </div>
                </div>

                <!-- Help Tab -->
                <div id="help-tab" class="page-content hide" data-tab-content="help">
                     <div style="margin-top:2em;">
                        <h3 class="section-title">Need Help?</h3>
                        <p>For detailed instructions and bug reports, please see the following GitHub repository.</p>
                        <a href="https://github.com/jyourstone/jellyfin-smartplaylist-plugin" target="_blank" style="text-decoration: none;">
                            <button is="emby-button" class="emby-button raised">
                                <span class="material-icons open_in_new" style="margin-right: 0.5em;"></span>
                                View on GitHub
                            </button>
                        </a>
                    </div>
                </div>

            </div>
        </div>

        <div id="delete-confirm-modal" class="custom-modal hide">
            <div class="custom-modal-container">
                <div class="modal-content">
                    <div class="custom-modal-header">
                        <h3 class="custom-modal-title">Confirm Deletion</h3>
                    </div>
                    <div class="custom-modal-body">
                        <p id="delete-confirm-text"></p>
                        <div style="margin-top: 1em; padding: 0.5em; background-color: #3a3a3a; border-radius: 4px;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox" id="delete-jellyfin-playlist-checkbox" checked style="margin-right: 0.5em;">
                                <span>Also delete the Jellyfin playlist</span>
                            </label>
                            <div style="font-size: 0.9em; color: #aaa; margin-top: 0.5em;">
                                <strong>Unchecked:</strong> Only delete the smart playlist configuration. The Jellyfin playlist will remain and can be managed manually.<br><br>
                                <strong>Checked:</strong> Delete both the smart playlist configuration and the Jellyfin playlist.
                            </div>
                        </div>
                    </div>
                    <div class="custom-modal-footer">
                        <button type="button" is="emby-button" class="emby-button raised" id="delete-cancel-btn">Cancel</button>
                        <button type="button" is="emby-button" class="emby-button raised button-submit" id="delete-confirm-btn">Delete</button>
                    </div>
                </div>
            </div>
        </div>

        <script>
        (function () {
            'use strict';
            
            // Constants
            const PLUGIN_ID = "A0A2A7B2-747A-4113-8B39-757A9D267C79";
            const ENDPOINTS = {
                fields: 'Plugins/SmartPlaylist/fields',
                base: 'Plugins/SmartPlaylist',
                users: 'Plugins/SmartPlaylist/users',
                refresh: 'Plugins/SmartPlaylist/refresh'
            };
            
            function getPluginId() {
                return PLUGIN_ID;
            }

            let availableFields = {};
            let notificationTimeout;
            let pageInitialized = false;
            let tabListenersInitialized = false;
            let editMode = false;
            let editingPlaylistId = null;
            let currentModalBackdropHandler = null; // Track the current modal backdrop handler
            const mediaTypes = [ { Value: "Movie", Label: "Movie" }, { Value: "Episode", Label: "Episode (TV Show)" }, { Value: "Audio", Label: "Audio (Music)" } ];

            function showNotification(message, type = 'error') {
                const notificationArea = document.querySelector('#plugin-notification-area');
                if (!notificationArea) return;

                notificationArea.textContent = message;
                notificationArea.style.color = 'white';
                notificationArea.style.backgroundColor = 
                    type === 'success' ? '#3e8e41' : 
                    type === 'warning' ? '#ff9800' : '#d9534f';
                notificationArea.style.display = 'block';

                clearTimeout(notificationTimeout);
                notificationTimeout = setTimeout(() => {
                    notificationArea.style.display = 'none';
                }, 5000);
            }

            function getApiClient() {
                return window.ApiClient;
            }

            function loadAndPopulateFields(page) {
                const apiClient = getApiClient();
                const url = apiClient.getUrl(ENDPOINTS.fields);
                
                return apiClient.get(url).then(response => {
                    if (!response.ok) { throw new Error(`Network response was not ok: ${response.statusText}`); }
                    return response.json();
                }).then(fields => {
                    availableFields = fields;
                    return fields;
                }).catch(err => {
                    console.error('Error loading or parsing fields:', err);
                    throw err;
                });
            }

            function populateSelect(selectElement, options, defaultValue = null, forceSelection = true) {
                if (!selectElement) return;
                options.forEach((opt, index) => {
                    const option = document.createElement('option');
                    option.value = opt.Value;
                    option.textContent = opt.Label;
                    selectElement.appendChild(option);
                    
                    if ((defaultValue && opt.Value === defaultValue) || (!defaultValue && forceSelection && index === 0)) {
                        option.selected = true;
                    }
                });
            }

            function populateStaticSelects(page) {
                 const sortOptions = [
                    { Value: 'Name', Label: 'Name' },
                    { Value: 'ProductionYear', Label: 'Production Year' },
                    { Value: 'CommunityRating', Label: 'Community Rating' },
                    { Value: 'DateCreated', Label: 'Date Created' },
                    { Value: 'NoOrder', Label: 'No Order' }
                ];
                const orderOptions = [
                    { Value: 'Ascending', Label: 'Ascending' },
                    { Value: 'Descending', Label: 'Descending' }
                ];

                const sortByContainer = page.querySelector('#sortBy-container');
                const sortOrderContainer = page.querySelector('#sortOrder-container');
                
                let sortBySelect = page.querySelector('#sortBy');
                if (!sortBySelect) {
                    sortBySelect = document.createElement('select');
                    sortBySelect.setAttribute('is', 'emby-select');
                    sortBySelect.className = 'emby-select';
                    sortBySelect.id = 'sortBy';
                    sortByContainer.appendChild(sortBySelect);
                }
                
                let sortOrderSelect = page.querySelector('#sortOrder');
                if (!sortOrderSelect) {
                    sortOrderSelect = document.createElement('select');
                    sortOrderSelect.setAttribute('is', 'emby-select');
                    sortOrderSelect.className = 'emby-select';
                    sortOrderSelect.id = 'sortOrder';
                    sortOrderContainer.appendChild(sortOrderSelect);
                }

                const apiClient = getApiClient();
                apiClient.getPluginConfiguration(getPluginId()).then(config => {
                    const defaultSortBy = config.DefaultSortBy || 'Name';
                    const defaultSortOrder = config.DefaultSortOrder || 'Ascending';
                    const defaultMakePublic = config.DefaultMakePublic || false;
                    
                    if (sortBySelect.children.length === 0) { populateSelect(sortBySelect, sortOptions, defaultSortBy); }
                    if (sortOrderSelect.children.length === 0) { populateSelect(sortOrderSelect, orderOptions, defaultSortOrder); }
                    page.querySelector('#playlistIsPublic').checked = defaultMakePublic;
                }).catch(() => {
                    if (sortBySelect.children.length === 0) { populateSelect(sortBySelect, sortOptions, 'Name'); }
                    if (sortOrderSelect.children.length === 0) { populateSelect(sortOrderSelect, orderOptions, 'Ascending'); }
                    page.querySelector('#playlistIsPublic').checked = false;
                });
                
                const defaultSortBy = page.querySelector('#defaultSortBy');
                const defaultSortOrder = page.querySelector('#defaultSortOrder');
                if (defaultSortBy && defaultSortBy.children.length === 0) { populateSelect(defaultSortBy, sortOptions, 'Name'); }
                if (defaultSortOrder && defaultSortOrder.children.length === 0) { populateSelect(defaultSortOrder, orderOptions, 'Ascending'); }
            }

            function updateOperatorOptions(fieldValue, operatorSelect) {
                operatorSelect.innerHTML = '<option value="">-- Select Operator --</option>';
                let allowedOperators = [];
                
                const listFields = ['People', 'Genres', 'Studios', 'Tags'];
                const numericFields = ['ProductionYear', 'CommunityRating', 'CriticRating', 'RuntimeMinutes', 'PlayCount'];
                const dateFields = ['DateCreated', 'DateLastRefreshed', 'DateLastSaved', 'DateModified'];
                const booleanFields = ['IsPlayed', 'IsFavorite'];
                const simpleFields = ['ItemType'];

                if (listFields.includes(fieldValue)) {
                    allowedOperators = availableFields.Operators.filter(op => op.Value === 'Contains' || op.Value === 'NotContains' || op.Value === 'MatchRegex');
                } else if (numericFields.includes(fieldValue) || dateFields.includes(fieldValue)) {
                    allowedOperators = availableFields.Operators.filter(op => op.Value !== 'Contains' && op.Value !== 'NotContains' && op.Value !== 'MatchRegex');
                } else if (booleanFields.includes(fieldValue) || simpleFields.includes(fieldValue)) {
                    allowedOperators = availableFields.Operators.filter(op => op.Value === 'Equal' || op.Value === 'NotEqual');
                } else { // Default to string fields
                    allowedOperators = availableFields.Operators.filter(op => op.Value === 'Equal' || op.Value === 'NotEqual' || op.Value === 'Contains' || op.Value === 'NotContains' || op.Value === 'MatchRegex');
                }

                allowedOperators.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt.Value;
                    option.textContent = opt.Label;
                    operatorSelect.appendChild(option);
                });
                if (fieldValue === 'ItemType' || fieldValue === 'IsPlayed' || fieldValue === 'IsFavorite') { operatorSelect.value = 'Equal'; }
            }

            function setValueInput(fieldValue, valueContainer) {
                valueContainer.innerHTML = '';

                const numericFields = ['ProductionYear', 'CommunityRating', 'CriticRating', 'RuntimeMinutes', 'PlayCount'];
                const dateFields = ['DateCreated', 'DateLastRefreshed', 'DateLastSaved', 'DateModified'];
                const booleanFields = ['IsPlayed', 'IsFavorite'];
                const simpleFields = ['ItemType'];

                if (simpleFields.includes(fieldValue)) {
                    const select = document.createElement('select');
                    select.className = 'emby-select rule-value-input';
                    select.setAttribute('is', 'emby-select');
                    select.style.width = '100%';
                    mediaTypes.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.Value;
                        option.textContent = opt.Label;
                        select.appendChild(option);
                    });
                    valueContainer.appendChild(select);
                } else if (booleanFields.includes(fieldValue)) {
                    const select = document.createElement('select');
                    select.className = 'emby-select rule-value-input';
                    select.setAttribute('is', 'emby-select');
                    select.style.width = '100%';
                    let boolOptions;
                    if (fieldValue === 'IsPlayed') {
                        boolOptions = [ { Value: "true", Label: "Yes (Played)" }, { Value: "false", Label: "No (Unplayed)" } ];
                    } else if (fieldValue === 'IsFavorite') {
                        boolOptions = [ { Value: "true", Label: "Yes (Favorite)" }, { Value: "false", Label: "No (Not Favorite)" } ];
                    } else {
                        boolOptions = [ { Value: "true", Label: "Yes" }, { Value: "false", Label: "No" } ];
                    }
                    boolOptions.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.Value;
                        option.textContent = opt.Label;
                        select.appendChild(option);
                    });
                    valueContainer.appendChild(select);
                } else if (numericFields.includes(fieldValue)) {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.className = 'emby-input rule-value-input';
                    input.placeholder = 'Value';
                    input.style.width = '100%';
                    valueContainer.appendChild(input);
                } else if (dateFields.includes(fieldValue)) {
                    const input = document.createElement('input');
                    input.type = 'date';
                    input.className = 'emby-input rule-value-input';
                    input.style.width = '100%';
                    valueContainer.appendChild(input);
                }
                else {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'emby-input rule-value-input';
                    input.placeholder = 'Value';
                    input.style.width = '100%';
                    valueContainer.appendChild(input);
                }
            }
            
            function updateRegexHelp(ruleGroup) {
                const operatorSelect = ruleGroup.querySelector('.rule-operator-select');
                const existingHelp = ruleGroup.querySelector('.regex-help');
                if (existingHelp) existingHelp.remove();
                
                if (operatorSelect && operatorSelect.value === 'MatchRegex') {
                    const helpDiv = document.createElement('div');
                    helpDiv.className = 'regex-help field-description';
                    helpDiv.style.cssText = 'margin-top: 0.5em; margin-bottom: 0.5em; font-size: 0.85em; color: #aaa; background: rgba(255,255,255,0.05); padding: 0.5em; border-radius: 3px;';
                    helpDiv.innerHTML = '<strong>Regex Help:</strong> Use .NET syntax. Examples: <code>(?i)swe</code> (case-insensitive), <code>(?i)(eng|en)</code> (multiple options), <code>^Action</code> (starts with). Do not use JavaScript-style /pattern/flags.<br><strong>Test patterns:</strong> <a href="https://regex101.com/?flavor=dotnet" target="_blank" style="color: #00a4dc;">Regex101.com (.NET flavor)</a>';
                    ruleGroup.appendChild(helpDiv);
                }
            }

            function createInitialLogicGroup(page) {
                const rulesContainer = page.querySelector('#rules-container');
                const logicGroupId = 'logic-group-' + Date.now();
                
                const logicGroupDiv = document.createElement('div');
                logicGroupDiv.className = 'logic-group';
                logicGroupDiv.setAttribute('data-group-id', logicGroupId);
                
                // Apply styles directly via JavaScript to bypass CSS specificity issues
                logicGroupDiv.style.cssText = `
                    border: 2px solid #666 !important;
                    border-radius: 8px !important;
                    padding: 1.5em 1.5em 0.5em 1.5em !important;
                    margin-bottom: 1em !important;
                    background: rgba(255, 255, 255, 0.05) !important;
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3) !important;
                    position: relative !important;
                `;
                
                rulesContainer.appendChild(logicGroupDiv);
                
                // Add the first rule to this group
                addRuleToGroup(page, logicGroupDiv);
                
                return logicGroupDiv;
            }

            function addRuleToGroup(page, logicGroup) {
                const existingRules = logicGroup.querySelectorAll('.rule-row');
                
                // Add AND separator if this isn't the first rule in the group
                if (existingRules.length > 0) {
                    const andSeparator = document.createElement('div');
                    andSeparator.className = 'rule-within-group-separator';
                    andSeparator.style.cssText = `
                        text-align: center !important;
                        margin: 0.8em 0 !important;
                        color: #888 !important;
                        font-size: 0.8em !important;
                        font-weight: bold !important;
                        position: relative !important;
                        padding: 0.3em 0 !important;
                    `;
                    andSeparator.textContent = 'AND';
                    
                    // Add subtle line behind AND text
                    const line = document.createElement('div');
                    line.style.cssText = `
                        position: absolute !important;
                        top: 50% !important;
                        left: 20% !important;
                        right: 20% !important;
                        height: 1px !important;
                        background: rgba(136, 136, 136, 0.3) !important;
                        z-index: 1 !important;
                    `;
                    andSeparator.appendChild(line);
                    
                    logicGroup.appendChild(andSeparator);
                }
                
                const ruleDiv = document.createElement('div');
                ruleDiv.className = 'rule-row';
                ruleDiv.setAttribute('data-rule-id', 'rule-' + Date.now());

                const fieldsHtml = `
                    <div class="input-group" style="display: flex; gap: 0.5em; align-items: center; margin-bottom: 1em;">
                        <select is="emby-select" class="emby-select rule-field-select" style="flex: 0 0 25%;">
                            <option value="">-- Select Field --</option>
                        </select>
                        <select is="emby-select" class="emby-select rule-operator-select" style="flex: 0 0 20%;">
                            <option value="">-- Select Operator --</option>
                        </select>
                        <span class="rule-value-container" style="flex: 1;">
                            <input type="text" class="emby-input rule-value-input" placeholder="Value" style="width: 100%;">
                        </span>
                        <div class="rule-actions">
                            <button type="button" class="rule-action-btn and-btn" title="Add AND rule">And</button>
                            <button type="button" class="rule-action-btn or-btn" title="Add OR group">Or</button>
                            <button type="button" class="rule-action-btn delete-btn" title="Remove rule">×</button>
                        </div>
                    </div>`;
                
                ruleDiv.innerHTML = fieldsHtml;
                logicGroup.appendChild(ruleDiv);
                
                const newRuleRow = logicGroup.lastElementChild;
                const fieldSelect = newRuleRow.querySelector('.rule-field-select');
                const operatorSelect = newRuleRow.querySelector('.rule-operator-select');
                const valueContainer = newRuleRow.querySelector('.rule-value-container');

                if (availableFields.ContentFields) {
                    populateSelect(fieldSelect, availableFields.ContentFields.concat(availableFields.RatingsPlaybackFields, availableFields.DateFields, availableFields.FileFields, availableFields.CollectionFields), null, false);
                }
                if (availableFields.Operators) {
                    populateSelect(operatorSelect, availableFields.Operators, null, false);
                }

                setValueInput(fieldSelect.value, valueContainer);
                updateOperatorOptions(fieldSelect.value, operatorSelect);
                
                fieldSelect.addEventListener('change', function() {
                    setValueInput(fieldSelect.value, valueContainer);
                    updateOperatorOptions(fieldSelect.value, operatorSelect);
                    updateRegexHelp(newRuleRow);
                });
                
                operatorSelect.addEventListener('change', function() {
                    updateRegexHelp(newRuleRow);
                });

                // Style the action buttons
                const actionButtons = newRuleRow.querySelectorAll('.rule-action-btn');
                actionButtons.forEach(button => {
                    if (button.classList.contains('and-btn')) {
                        button.style.cssText = `
                            padding: 0.3em 0.8em !important;
                            font-size: 0.8em !important;
                            border: 1px solid #666 !important;
                            background: rgba(255, 255, 255, 0.1) !important;
                            color: #aaa !important;
                            border-radius: 4px !important;
                            cursor: pointer !important;
                            font-weight: 500 !important;
                        `;
                    } else if (button.classList.contains('or-btn')) {
                        button.style.cssText = `
                            padding: 0.3em 0.8em !important;
                            font-size: 0.8em !important;
                            border: 1px solid #777 !important;
                            background: rgba(255, 255, 255, 0.15) !important;
                            color: #bbb !important;
                            border-radius: 4px !important;
                            cursor: pointer !important;
                            font-weight: 500 !important;
                        `;
                    } else if (button.classList.contains('delete-btn')) {
                        button.style.cssText = `
                            padding: 0.3em 0.8em !important;
                            font-size: 0.8em !important;
                            border: 1px solid #888 !important;
                            background: rgba(255, 255, 255, 0.08) !important;
                            color: #999 !important;
                            border-radius: 4px !important;
                            cursor: pointer !important;
                            font-weight: 600 !important;
                            line-height: 1.2 !important;
                            display: inline-flex !important;
                            align-items: center !important;
                            justify-content: center !important;
                        `;
                    }
                    
                    // Add hover effects
                    button.addEventListener('mouseenter', function() {
                        if (this.classList.contains('delete-btn')) {
                            this.style.background = 'rgba(255, 100, 100, 0.2) !important';
                            this.style.borderColor = '#ff6464 !important';
                            this.style.color = '#ff6464 !important';
                        } else {
                            this.style.background = 'rgba(255, 255, 255, 0.25) !important';
                            this.style.borderColor = '#aaa !important';
                        }
                    });
                    
                    button.addEventListener('mouseleave', function() {
                        if (this.classList.contains('and-btn')) {
                            this.style.background = 'rgba(255, 255, 255, 0.1) !important';
                            this.style.borderColor = '#666 !important';
                            this.style.color = '#aaa !important';
                        } else if (this.classList.contains('or-btn')) {
                            this.style.background = 'rgba(255, 255, 255, 0.15) !important';
                            this.style.borderColor = '#777 !important';
                            this.style.color = '#bbb !important';
                        } else if (this.classList.contains('delete-btn')) {
                            this.style.background = 'rgba(255, 255, 255, 0.08) !important';
                            this.style.borderColor = '#888 !important';
                            this.style.color = '#999 !important';
                        }
                    });
                });

                // Update button visibility for all rules in all groups
                updateRuleButtonVisibility(page);
            }

            function addNewLogicGroup(page) {
                const rulesContainer = page.querySelector('#rules-container');
                
                // Add OR separator between groups
                const orSeparator = document.createElement('div');
                orSeparator.className = 'logic-group-separator';
                orSeparator.style.cssText = `
                    text-align: center !important;
                    margin: 1em 0 !important;
                    position: relative !important;
                `;
                
                // Create OR text with styling
                const orText = document.createElement('span');
                orText.style.cssText = `
                    background: #1a1a1a !important;
                    color: #bbb !important;
                    padding: 0.4em !important;
                    border-radius: 4px !important;
                    font-weight: bold !important;
                    font-size: 0.9em !important;
                    position: relative !important;
                    z-index: 2 !important;
                    display: inline-block !important;
                    border: 1px solid #777 !important;
                    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4) !important;
                `;
                orText.textContent = 'OR';
                orSeparator.appendChild(orText);
                
                // Add gradient line behind OR text
                const gradientLine = document.createElement('div');
                gradientLine.style.cssText = `
                    position: absolute !important;
                    top: 50% !important;
                    left: 0 !important;
                    right: 0 !important;
                    height: 2px !important;
                    background: linear-gradient(to right, transparent, #777, transparent) !important;
                    z-index: 1 !important;
                `;
                orSeparator.appendChild(gradientLine);
                
                rulesContainer.appendChild(orSeparator);
                
                // Create new logic group
                const logicGroupId = 'logic-group-' + Date.now();
                const logicGroupDiv = document.createElement('div');
                logicGroupDiv.className = 'logic-group';
                logicGroupDiv.setAttribute('data-group-id', logicGroupId);
                
                // Apply styles directly via JavaScript to bypass CSS specificity issues
                logicGroupDiv.style.cssText = `
                    border: 2px solid #666 !important;
                    border-radius: 8px !important;
                    padding: 1.5em 1.5em 0.5em 1.5em !important;
                    margin-bottom: 1em !important;
                    background: rgba(255, 255, 255, 0.05) !important;
                    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3) !important;
                    position: relative !important;
                `;
                
                rulesContainer.appendChild(logicGroupDiv);
                
                // Add the first rule to this group
                addRuleToGroup(page, logicGroupDiv);
                
                return logicGroupDiv;
            }

            function removeRule(page, ruleElement) {
                const logicGroup = ruleElement.closest('.logic-group');
                const rulesInGroup = logicGroup.querySelectorAll('.rule-row');
                
                if (rulesInGroup.length === 1) {
                    // This is the last rule in the group, remove the entire group
                    removeLogicGroup(page, logicGroup);
                } else {
                    // Remove the rule and any adjacent separator
                    const nextSibling = ruleElement.nextElementSibling;
                    const prevSibling = ruleElement.previousElementSibling;
                    
                    if (nextSibling && nextSibling.classList.contains('rule-within-group-separator')) {
                        nextSibling.remove();
                    } else if (prevSibling && prevSibling.classList.contains('rule-within-group-separator')) {
                        prevSibling.remove();
                    }
                    
                    ruleElement.remove();
                    updateRuleButtonVisibility(page);
                }
            }

            function removeLogicGroup(page, logicGroup) {
                const rulesContainer = page.querySelector('#rules-container');
                const allGroups = rulesContainer.querySelectorAll('.logic-group');
                
                if (allGroups.length === 1) {
                    // This is the last group, clear it and add a new rule
                    logicGroup.innerHTML = '';
                    addRuleToGroup(page, logicGroup);
                } else {
                    // Remove the group and any adjacent separator
                    const nextSibling = logicGroup.nextElementSibling;
                    const prevSibling = logicGroup.previousElementSibling;
                    
                    if (prevSibling && prevSibling.classList.contains('logic-group-separator')) {
                        prevSibling.remove();
                    } else if (nextSibling && nextSibling.classList.contains('logic-group-separator')) {
                        nextSibling.remove();
                    }
                    
                    logicGroup.remove();
                    updateRuleButtonVisibility(page);
                }
            }

            function updateRuleButtonVisibility(page) {
                const rulesContainer = page.querySelector('#rules-container');
                const allLogicGroups = rulesContainer.querySelectorAll('.logic-group');
                
                allLogicGroups.forEach(group => {
                    const rulesInGroup = group.querySelectorAll('.rule-row');
                    
                    rulesInGroup.forEach((rule, index) => {
                        const andBtn = rule.querySelector('.and-btn');
                        const orBtn = rule.querySelector('.or-btn');
                        const deleteBtn = rule.querySelector('.delete-btn');
                        
                        // Hide AND and OR buttons if this is not the last rule in the group
                        if (index < rulesInGroup.length - 1) {
                            andBtn.style.display = 'none';
                            orBtn.style.display = 'none';
                        } else {
                            andBtn.style.display = 'inline-flex';
                            orBtn.style.display = 'inline-flex';
                        }
                        
                        // Always show DELETE button
                        deleteBtn.style.display = 'inline-flex';
                    });
                });
            }
            
            async function createPlaylist(page) {
                try {
                    const apiClient = getApiClient();
                    const playlistName = page.querySelector('#playlistName').value;

                    if (!playlistName) {
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                        showNotification('Playlist name is required.');
                        return;
                    }

                    const expressionSets = [];
                    page.querySelectorAll('.logic-group').forEach(logicGroup => {
                        const expressions = [];
                        logicGroup.querySelectorAll('.rule-row').forEach(rule => {
                            const memberName = rule.querySelector('.rule-field-select').value;
                            const operator = rule.querySelector('.rule-operator-select').value;
                            const targetValue = rule.querySelector('.rule-value-input').value;
                            if (memberName && operator && targetValue) {
                                expressions.push({ MemberName: memberName, Operator: operator, TargetValue: targetValue });
                            }
                        });
                        if (expressions.length > 0) {
                            expressionSets.push({ Expressions: expressions });
                        }
                    });

                    const selectedMediaTypes = [];
                    const mediaTypesSelect = page.querySelectorAll('.media-type-checkbox');
                    mediaTypesSelect.forEach(checkbox => {
                        if (checkbox.checked) {
                            selectedMediaTypes.push(checkbox.value);
                        }
                    });
                    if (selectedMediaTypes.length === 0) {
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                        showNotification('At least one media type must be selected.');
                        return;
                    }

                    const sortByElement = page.querySelector('#sortBy');
                    const sortOrderElement = page.querySelector('#sortOrder');
                    const sortByValue = sortByElement?.value || 'Name';
                    const sortOrderValue = sortOrderElement?.value || 'Ascending';
                    const orderName = sortByValue + ' ' + sortOrderValue;
                    const isPublic = page.querySelector('#playlistIsPublic').checked || false;

                    // Get selected user ID from dropdown
                    const userId = page.querySelector('#playlistUser').value;
                    
                    if (!userId) {
                        showNotification('Please select a playlist owner.');
                        return;
                    }

                    const playlistDto = {
                        Name: playlistName,
                        ExpressionSets: expressionSets,
                        Order: { Name: orderName },
                        Public: isPublic,
                        UserId: userId,
                        MediaTypes: selectedMediaTypes
                    };

                    // Add ID if in edit mode
                    if (editMode && editingPlaylistId) {
                        playlistDto.Id = editingPlaylistId;
                    }

                    Dashboard.showLoadingMsg();
                    
                    const requestType = editMode ? "PUT" : "POST";
                    const url = editMode ? 
                        apiClient.getUrl(ENDPOINTS.base + '/' + editingPlaylistId) : 
                        apiClient.getUrl(ENDPOINTS.base);
                    
                    apiClient.ajax({
                        type: requestType,
                        url: url,
                        data: JSON.stringify(playlistDto),
                        contentType: 'application/json'
                    }).then(result => {
                        Dashboard.hideLoadingMsg();
                        const action = editMode ? 'updated' : 'created';
                        const actionPast = editMode ? 'updated' : 'created';
                        const actionFuture = editMode ? 'updated' : 'generated';
                        showNotification('Playlist "' + playlistName + '" ' + actionPast + '. The playlist has been ' + actionFuture + '.', 'success');
                        
                        // Exit edit mode and clear form
                        if (editMode) {
                            // Exit edit mode silently without showing cancellation message
                            editMode = false;
                            editingPlaylistId = null;
                            const editIndicator = page.querySelector('#edit-mode-indicator');
                            editIndicator.style.display = 'none';
                            page.querySelector('#current-tab-title').textContent = 'Create Playlist';
                            page.querySelector('#submitBtn').textContent = 'Create Playlist';
                            
                            // Restore tab button text
                            const createTabButton = page.querySelector('.emby-tab-button[data-tab="create"] .emby-tab-button-title');
                            if (createTabButton) {
                                createTabButton.textContent = 'Create Playlist';
                            }
                        }
                        clearForm(page);
                    }).catch(err => {
                        Dashboard.hideLoadingMsg();
                        if (err && typeof err.text === 'function') {
                            err.text().then(serverMessage => {
                                let friendlyMessage = 'An error occurred on the server.';
                                try {
                                    friendlyMessage = JSON.parse(serverMessage) || friendlyMessage;
                                } catch (e) {
                                    friendlyMessage = serverMessage || friendlyMessage;
                                }
                                showNotification(friendlyMessage);
                            }).catch(() => {
                                showNotification('Could not read error response from server. Status: ' + (err.status || 'Unknown'));
                            });
                        } else {
                            showNotification((err && err.message) ? err.message : 'An unknown network error occurred.');
                        }
                    });
                } catch (e) {
                    Dashboard.hideLoadingMsg();
                    console.error('A synchronous error occurred in createPlaylist:', e);
                    showNotification('A critical client-side error occurred: ' + e.message);
                }
            }
            
            function clearForm(page) {
                // Only handle form clearing - edit mode management should be done by caller
                
                page.querySelector('#playlistName').value = '';
                page.querySelector('#rules-container').innerHTML = '';
                
                // Clear media type selections
                const mediaTypesSelect = page.querySelectorAll('.media-type-checkbox');
                mediaTypesSelect.forEach(checkbox => {
                    checkbox.checked = false;
                });
                
                const apiClient = getApiClient();
                apiClient.getPluginConfiguration(getPluginId()).then(config => {
                    page.querySelector('#sortBy').value = config.DefaultSortBy || 'Name';
                    page.querySelector('#sortOrder').value = config.DefaultSortOrder || 'Ascending';
                    page.querySelector('#playlistIsPublic').checked = config.DefaultMakePublic || false;
                }).catch(() => {
                    page.querySelector('#sortBy').value = 'Name';
                    page.querySelector('#sortOrder').value = 'Ascending';
                    page.querySelector('#playlistIsPublic').checked = false;
                });
                
                // Create initial logic group with one rule
                createInitialLogicGroup(page);
                
                // Update button visibility after initial group is created
                updateRuleButtonVisibility(page);
            }

            async function loadUsers(page) {
                const apiClient = getApiClient();
                const userSelect = page.querySelector('#playlistUser');
                
                try {
                    const response = await apiClient.ajax({
                        type: "GET",
                        url: apiClient.getUrl(ENDPOINTS.users),
                        contentType: 'application/json'
                    });
                    
                    const users = await response.json();
                    
                    // Clear existing options
                    userSelect.innerHTML = '';
                    
                    // Add user options
                    users.forEach(user => {
                        const option = document.createElement('option');
                        option.value = user.Id;
                        option.textContent = user.Name;
                        userSelect.appendChild(option);
                    });
                    
                    // Set current user as default
                    await setCurrentUserAsDefault(page);
                    
                } catch (err) {
                    console.error('Error loading users:', err);
                    userSelect.innerHTML = '<option value="">Error loading users</option>';
                    showNotification('Failed to load users. Using fallback.');
                }
            }
            
            async function setCurrentUserAsDefault(page) {
                const apiClient = getApiClient();
                const userSelect = page.querySelector('#playlistUser');
                
                try {
                    // Use client-side method to get current user
                    let userId = apiClient.getCurrentUserId();
                    if (!userId) {
                        const user = await apiClient.getCurrentUser();
                        userId = user?.Id;
                    }
                    if (userId) {
                        userSelect.value = userId;
                    }
                } catch (err) {
                    console.error('Error setting current user as default:', err);
                }
            }

            async function resolveUsername(apiClient, playlist) {
                // Handle both old User field and new UserId field
                if (playlist.UserId && playlist.UserId !== '00000000-0000-0000-0000-000000000000') {
                    try {
                        const user = await apiClient.getUser(playlist.UserId);
                        return user?.Name || 'Unknown User';
                    } catch (err) {
                        console.error('Error resolving user ID ' + playlist.UserId + ':', err);
                        return 'Unknown User';
                    }
                } else if (playlist.User) {
                    // Legacy format - username is directly stored
                    return playlist.User;
                }
                return 'Unknown User';
            }

            function loadPlaylistList(page) {
                const apiClient = getApiClient();
                const container = page.querySelector('#playlist-list-container');
                container.innerHTML = '<p>Loading playlists...</p>';
                
                apiClient.ajax({
                    type: "GET",
                    url: apiClient.getUrl(ENDPOINTS.base),
                    contentType: 'application/json'
                }).then(response => {
                    if (!response.ok) { throw new Error('HTTP ' + response.status + ': ' + response.statusText); }
                    return response.json();
                }).then(async playlists => {
                    if (playlists && playlists.length > 0) {
                        let html = '<div class="input-container"><h3 class="section-title">Existing Smart Playlists</h3></div>';
                        
                        // Process playlists sequentially to resolve usernames
                        for (const playlist of playlists) {
                            const isPublic = playlist.Public ? 'Public' : 'Private';
                            const sortName = playlist.Order ? playlist.Order.Name : 'Default';
                            const userName = await resolveUsername(apiClient, playlist);
                            const playlistId = playlist.Id || 'NO_ID';
                            const mediaTypes = playlist.MediaTypes && playlist.MediaTypes.length > 0 ? 
                                playlist.MediaTypes.join(', ') : 'All Types';
                            
                            let rulesHtml = '';
                            if (playlist.ExpressionSets && playlist.ExpressionSets.length > 0) {
                                playlist.ExpressionSets.forEach((expressionSet, groupIndex) => {
                                    if (groupIndex > 0) {
                                        rulesHtml += '<strong style="color: #888;">OR</strong><br>';
                                    }
                                    
                                    if (expressionSet.Expressions && expressionSet.Expressions.length > 0) {
                                        rulesHtml += '<div style="border: 1px solid #555; padding: 0.5em; margin: 0.25em 0; border-radius: 3px; background: rgba(255,255,255,0.02);">';
                                        
                                        expressionSet.Expressions.forEach((rule, ruleIndex) => {
                                            if (ruleIndex > 0) {
                                                rulesHtml += '<br><em style="color: #888; font-size: 0.9em;">AND</em><br>';
                                            }
                                            
                                            let fieldName = rule.MemberName;
                                            if (fieldName === 'ItemType') fieldName = 'Media Type';
                                            let operator = rule.Operator;
                                            switch(operator) {
                                                case 'Equal': operator = 'equals'; break;
                                                case 'NotEqual': operator = 'not equals'; break;
                                                case 'Contains': operator = 'contains'; break;
                                                case 'NotContains': operator = "not contains"; break;
                                                case 'GreaterThan': operator = '>'; break;
                                                case 'LessThan': operator = '<'; break;
                                                case 'GreaterThanOrEqual': operator = '>='; break;
                                                case 'LessThanOrEqual': operator = '<='; break;
                                                case 'MatchRegex': operator = 'matches regex'; break;
                                            }
                                            let value = rule.TargetValue;
                                            if (rule.MemberName === 'IsPlayed') { value = value === 'true' ? 'Yes (Played)' : 'No (Unplayed)'; }
                                            rulesHtml += '<span style="font-family: monospace; background: rgba(255,255,255,0.1); padding: 2px 2px; border-radius: 2px;">' + fieldName + ' ' + operator + ' "' + value + '"</span>';
                                        });
                                        
                                        rulesHtml += '</div>';
                                    }
                                });
                            } else {
                                rulesHtml = '<em>No rules defined</em>';
                            }
                            
                            html += '<div class="input-container" style="border: 1px solid #444; padding: 1em; border-radius: 4px; margin-bottom: 1.5em;">' +
                                '<h4 style="margin-top: 0;">' + playlist.Name + '</h4>' +
                                '<div class="field-description">' +
                                '<strong>File:</strong> ' + playlist.FileName + '<br>' +
                                '<strong>User:</strong> ' + userName + '<br>' +
                                '<strong>Media Types:</strong> ' + mediaTypes + '<br>' +
                                '<strong>Rules:</strong><br>' + rulesHtml + '<br>' +
                                '<strong>Sort:</strong> ' + sortName + '<br>' +
                                '<strong>Visibility:</strong> ' + isPublic +
                                '</div>' +
                                '<div style="margin-top: 1em;">' +
                                '<button type="button" is="emby-button" class="emby-button raised edit-playlist-btn" data-playlist-id="' + playlistId + '" style="margin-right: 0.5em;">Edit</button>' +
                                '<button type="button" is="emby-button" class="emby-button raised delete-playlist-btn" data-playlist-id="' + playlistId + '" data-playlist-name="' + playlist.Name + '">Delete</button>' +
                                '</div>' +
                                '</div>';
                        }
                        container.innerHTML = html;
                    } else {
                        container.innerHTML = '<div class="input-container"><p>No smart playlists found.</p></div>';
                    }
                }).catch(err => {
                    console.error('Error loading playlists:', err);
                    let errorMessage = (err && err.message) ? err.message : 'Unknown error occurred.';
                    container.innerHTML = '<div class="input-container"><p style="color: #ff6b6b;">' + errorMessage + '</p></div>';
                });
            }

            function deletePlaylist(page, playlistId, playlistName) {
                const apiClient = getApiClient();
                const deleteJellyfinPlaylist = page.querySelector('#delete-jellyfin-playlist-checkbox').checked;
                
                Dashboard.showLoadingMsg();
                apiClient.ajax({
                    type: "DELETE",
                    url: apiClient.getUrl(ENDPOINTS.base + '/' + playlistId + '?deleteJellyfinPlaylist=' + deleteJellyfinPlaylist),
                    contentType: 'application/json'
                }).then(() => {
                    Dashboard.hideLoadingMsg();
                    const action = deleteJellyfinPlaylist ? 'deleted' : 'configuration deleted and [Smart] suffix removed';
                    showNotification('Playlist "' + playlistName + '" ' + action + ' successfully.', 'success');
                    loadPlaylistList(page);
                }).catch(err => {
                    Dashboard.hideLoadingMsg();
                    console.error('Error deleting playlist:', err);
                    showNotification('Failed to delete playlist "' + playlistName + '". Check console for details.');
                });
            }

            function showDeleteConfirm(page, playlistId, playlistName, buttonElement) {
                const modal = page.querySelector('#delete-confirm-modal');
                if (!modal) return;
                
                const modalContainer = modal.querySelector('.custom-modal-container');
                const confirmText = modal.querySelector('#delete-confirm-text');
                const confirmBtn = modal.querySelector('#delete-confirm-btn');
                const cancelBtn = modal.querySelector('#delete-cancel-btn');

                // Remove any existing backdrop listener to prevent accumulation
                if (currentModalBackdropHandler) {
                    modal.removeEventListener('click', currentModalBackdropHandler);
                    currentModalBackdropHandler = null;
                }

                // Force positioning with JavaScript since CSS isn't working reliably
                modalContainer.style.position = 'fixed';
                modalContainer.style.top = '50%';
                modalContainer.style.left = '50%';
                modalContainer.style.transform = 'translate(-50%, -50%)';
                modalContainer.style.zIndex = '10001';
                modalContainer.style.backgroundColor = '#2a2a2a';
                modalContainer.style.border = '1px solid #555';
                modalContainer.style.borderRadius = '8px';
                modalContainer.style.padding = '1.5em';
                modalContainer.style.width = '90%';
                modalContainer.style.maxWidth = '400px';
                modalContainer.style.boxShadow = '0 8px 32px rgba(0,0,0,0.8)';

                // Style the modal backdrop
                modal.style.position = 'fixed';
                modal.style.top = '0';
                modal.style.left = '0';
                modal.style.width = '100%';
                modal.style.height = '100%';
                modal.style.backgroundColor = 'rgba(0,0,0,0.75)';
                modal.style.zIndex = '10000';

                confirmText.textContent = 'Are you sure you want to delete the smart playlist "' + playlistName + '"? This cannot be undone.';
                
                // Reset checkbox to checked by default
                const checkbox = modal.querySelector('#delete-jellyfin-playlist-checkbox');
                if (checkbox) {
                    checkbox.checked = true;
                }
                
                // Show the modal
                modal.classList.remove('hide');
                
                // Remove any existing event listeners by cloning and replacing the elements
                const newConfirmBtn = confirmBtn.cloneNode(true);
                const newCancelBtn = cancelBtn.cloneNode(true);
                confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
                
                // Clean up function to close modal and remove backdrop listener
                const cleanupAndClose = () => {
                    modal.classList.add('hide');
                    if (currentModalBackdropHandler) {
                        modal.removeEventListener('click', currentModalBackdropHandler);
                        currentModalBackdropHandler = null;
                    }
                };
                
                const handleConfirm = () => {
                    deletePlaylist(page, playlistId, playlistName);
                    cleanupAndClose();
                };

                const handleCancel = () => {
                    cleanupAndClose();
                };
                
                const handleBackdropClick = (e) => {
                    if (e.target === modal) {
                        cleanupAndClose();
                    }
                };

                // Store reference to current handler and add fresh event listeners
                currentModalBackdropHandler = handleBackdropClick;
                newConfirmBtn.addEventListener('click', handleConfirm);
                newCancelBtn.addEventListener('click', handleCancel);
                modal.addEventListener('click', handleBackdropClick);
            }

            async function editPlaylist(page, playlistId) {
                const apiClient = getApiClient();
                Dashboard.showLoadingMsg();
                
                apiClient.ajax({
                    type: "GET",
                    url: apiClient.getUrl(ENDPOINTS.base + '/' + playlistId),
                    contentType: 'application/json'
                }).then(response => {
                    if (!response.ok) { throw new Error('HTTP ' + response.status + ': ' + response.statusText); }
                    return response.json();
                }).then(playlist => {
                    Dashboard.hideLoadingMsg();
                    
                    // Debug logging to see what we received
                    // console.log('Playlist data received:', playlist);
                    // console.log('Playlist name:', playlist ? playlist.Name : 'playlist is null/undefined');
                    // console.log('Playlist keys:', playlist ? Object.keys(playlist) : 'no keys');
                    
                    if (!playlist) {
                        showNotification('No playlist data received from server.');
                        return;
                    }
                    
                    try {
                        // Populate form with playlist data
                        page.querySelector('#playlistName').value = playlist.Name || '';
                        page.querySelector('#playlistIsPublic').checked = playlist.Public || false;
                        
                        // Set media types
                        const mediaTypesSelect = Array.from(page.querySelectorAll('.media-type-checkbox'));
                        if (playlist.MediaTypes && playlist.MediaTypes.length > 0) {
                            playlist.MediaTypes.forEach(type => {
                                const checkbox = mediaTypesSelect.find(checkbox => checkbox.value === type);
                                if (checkbox) {
                                    checkbox.checked = true;
                                }
                            });
                        }
                        
                        // Set the playlist owner
                        if (playlist.UserId && playlist.UserId !== '00000000-0000-0000-0000-000000000000') {
                            page.querySelector('#playlistUser').value = playlist.UserId;
                        } else if (playlist.User) {
                            // Legacy support: try to find user by username (simplified)
                            // Since this is legacy, just warn the user and use current user as fallback
                            console.warn('Legacy playlist detected with username:', playlist.User);
                            showNotification('Legacy playlist detected. Please verify the owner is correct.', 'warning');
                            setCurrentUserAsDefault(page);
                        }
                        
                        // Set sort options
                        const orderName = playlist.Order ? playlist.Order.Name : 'Name Ascending';
                        const parts = orderName.split(' ');
                        const sortBy = parts.slice(0, -1).join(' ') || 'Name';
                        const sortOrder = parts[parts.length - 1] || 'Ascending';
                        
                        page.querySelector('#sortBy').value = sortBy;
                        page.querySelector('#sortOrder').value = sortOrder;
                        
                        // Clear existing rules
                        const rulesContainer = page.querySelector('#rules-container');
                        rulesContainer.innerHTML = '';
                        
                        // Populate logic groups and rules
                        if (playlist.ExpressionSets && playlist.ExpressionSets.length > 0) {
                            playlist.ExpressionSets.forEach((expressionSet, groupIndex) => {
                                let logicGroup;
                                
                                if (groupIndex === 0) {
                                    // Create first logic group
                                    logicGroup = createInitialLogicGroup(page);
                                    // Remove only the rules, preserve the label
                                    const rulesToRemove = logicGroup.querySelectorAll('.rule-row, .rule-within-group-separator');
                                    rulesToRemove.forEach(rule => rule.remove());
                                } else {
                                    // Add subsequent logic groups
                                    logicGroup = addNewLogicGroup(page);
                                    // Remove only the rules, preserve the label
                                    const rulesToRemove = logicGroup.querySelectorAll('.rule-row, .rule-within-group-separator');
                                    rulesToRemove.forEach(rule => rule.remove());
                                }
                                
                                // Add rules to this logic group
                                if (expressionSet.Expressions && expressionSet.Expressions.length > 0) {
                                    expressionSet.Expressions.forEach(expression => {
                                        addRuleToGroup(page, logicGroup);
                                        const ruleRows = logicGroup.querySelectorAll('.rule-row');
                                        const currentRule = ruleRows[ruleRows.length - 1];
                                        
                                        const fieldSelect = currentRule.querySelector('.rule-field-select');
                                        const operatorSelect = currentRule.querySelector('.rule-operator-select');
                                        const valueContainer = currentRule.querySelector('.rule-value-container');
                                        
                                        fieldSelect.value = expression.MemberName;
                                        
                                        // Update UI elements based on the loaded rule data
                                        setValueInput(expression.MemberName, valueContainer);
                                        updateOperatorOptions(expression.MemberName, operatorSelect);
                                        
                                        // Set operator and value
                                        const valueInput = currentRule.querySelector('.rule-value-input');
                                        operatorSelect.value = expression.Operator;
                                        if (valueInput) {
                                            valueInput.value = expression.TargetValue;
                                        }
                                        
                                        updateRegexHelp(currentRule);
                                    });
                                } else {
                                    // Add one empty rule if no expressions exist in this group
                                    addRuleToGroup(page, logicGroup);
                                }
                            });
                        } else {
                            // Add one empty logic group with one rule if no expression sets exist
                            createInitialLogicGroup(page);
                        }
                        
                                                // If we get here, form population was successful - now enter edit mode
                        editMode = true;
                        editingPlaylistId = playlistId;
                        
                        // Update UI to show edit mode
                        const editIndicator = page.querySelector('#edit-mode-indicator');
                        editIndicator.style.display = 'block';
                        editIndicator.querySelector('span').textContent = '✏️ Editing Mode - Modifying existing playlist "' + playlist.Name + '"';
                        page.querySelector('#current-tab-title').textContent = 'Edit Playlist';
                        page.querySelector('#submitBtn').textContent = 'Update Playlist';
                        
                        // Update tab button text
                        const createTabButton = page.querySelector('.emby-tab-button[data-tab="create"] .emby-tab-button-title');
                        if (createTabButton) {
                            createTabButton.textContent = 'Edit Playlist';
                        }
                        
                        // Switch to create tab (which becomes edit tab)
                        const createTab = page.querySelector('.emby-tab-button[data-tab="create"]');
                        createTab.click();
                        
                        // Update button visibility after editing form is populated
                        updateRuleButtonVisibility(page);
                    
                    showNotification('Playlist "' + playlist.Name + '" loaded for editing.', 'success');
                        
                    } catch (formError) {
                        console.error('Error populating form:', formError);
                        showNotification('Error loading playlist data: ' + formError.message);
                    }
                }).catch(err => {
                    Dashboard.hideLoadingMsg();
                    console.error('Error loading playlist for edit:', err);
                    console.error('Error details:', err.status, err.statusText, err.message);
                    
                    if (err && typeof err.text === 'function') {
                        err.text().then(serverMessage => {
                            console.error('Server error message:', serverMessage);
                            let friendlyMessage = 'Failed to load playlist for editing.';
                            try {
                                friendlyMessage = JSON.parse(serverMessage) || friendlyMessage;
                            } catch (e) {
                                friendlyMessage = serverMessage || friendlyMessage;
                            }
                            showNotification(friendlyMessage);
                        }).catch(() => {
                            showNotification('Failed to load playlist for editing. HTTP ' + (err.status || 'Unknown'));
                        });
                    } else {
                        let errorMessage = 'Failed to load playlist for editing.';
                        if (err && err.message) {
                            errorMessage = errorMessage + ' Error: ' + err.message;
                        }
                        showNotification(errorMessage);
                    }
                });
            }

            function cancelEdit(page) {
                editMode = false;
                editingPlaylistId = null;
                
                // Update UI to show create mode
                const editIndicator = page.querySelector('#edit-mode-indicator');
                editIndicator.style.display = 'none';
                page.querySelector('#current-tab-title').textContent = 'Create Playlist';
                page.querySelector('#submitBtn').textContent = 'Create Playlist';
                
                // Restore tab button text
                const createTabButton = page.querySelector('.emby-tab-button[data-tab="create"] .emby-tab-button-title');
                if (createTabButton) {
                    createTabButton.textContent = 'Create Playlist';
                }
                
                // Clear form
                clearForm(page);
                
                showNotification('Edit mode cancelled.', 'success');
            }

            function loadConfiguration(page) {
                Dashboard.showLoadingMsg();
                getApiClient().getPluginConfiguration(getPluginId()).then(config => {
                    page.querySelector('#defaultSortBy').value = config.DefaultSortBy || 'Name';
                    page.querySelector('#defaultSortOrder').value = config.DefaultSortOrder || 'Ascending';
                    page.querySelector('#defaultMakePublic').checked = config.DefaultMakePublic || false;
                    Dashboard.hideLoadingMsg();
                }).catch(() => {
                    Dashboard.hideLoadingMsg();
                    showNotification('Could not load settings from server.');
                });
            }

            function saveConfiguration(page) {
                Dashboard.showLoadingMsg();
                const apiClient = getApiClient();
                apiClient.getPluginConfiguration(getPluginId()).then(config => {
                    config.DefaultSortBy = page.querySelector('#defaultSortBy').value;
                    config.DefaultSortOrder = page.querySelector('#defaultSortOrder').value;
                    config.DefaultMakePublic = page.querySelector('#defaultMakePublic').checked;
                    apiClient.updatePluginConfiguration(getPluginId(), config).then(() => {
                        Dashboard.hideLoadingMsg();
                        showNotification('Settings saved.', 'success');
                    }).catch(() => {
                        Dashboard.hideLoadingMsg();
                        showNotification('Failed to save settings.');
                    });
                }).catch(() => {
                    Dashboard.hideLoadingMsg();
                    showNotification('Could not load configuration from server.');
                });
            }

            function refreshAllPlaylists() {
                Dashboard.showLoadingMsg();
                
                getApiClient().ajax({
                    type: "POST",
                    url: getApiClient().getUrl(ENDPOINTS.refresh),
                    contentType: 'application/json'
                }).then(() => {
                    Dashboard.hideLoadingMsg();
                    showNotification('Smart playlist refresh task has been triggered. Playlists will be updated shortly.', 'success');
                }).catch(() => {
                    Dashboard.hideLoadingMsg();
                    showNotification('Failed to trigger playlist refresh. Please check server logs.');
                });
            }
            
            function initPage(page) {
                // Only initialize once to prevent duplicate event listeners
                if (pageInitialized) {
                    return;
                }
                pageInitialized = true;
                
                populateStaticSelects(page);
                loadUsers(page);
                loadAndPopulateFields(page).then(() => {
                    const rulesContainer = page.querySelector('#rules-container');
                    if (rulesContainer.children.length === 0) {
                        createInitialLogicGroup(page);
                    }
                }).catch(() => {
                    showNotification('Could not load rule options from server.');
                });

                page.addEventListener('click', function (e) {
                    const target = e.target;
                    
                    // Handle rule action buttons
                    if (target.classList.contains('and-btn')) {
                        const ruleRow = target.closest('.rule-row');
                        const logicGroup = ruleRow.closest('.logic-group');
                        addRuleToGroup(page, logicGroup);
                    }
                    if (target.classList.contains('or-btn')) {
                        addNewLogicGroup(page);
                    }
                    if (target.classList.contains('delete-btn')) {
                        const ruleRow = target.closest('.rule-row');
                        removeRule(page, ruleRow);
                    }
                    
                    // Handle other buttons
                    if (target.closest('#clearFormBtn')) { clearForm(page); }
                    if (target.closest('#saveSettingsBtn')) { saveConfiguration(page); }
                    if (target.closest('#refreshPlaylistsBtn')) { refreshAllPlaylists(); }
                    if (target.closest('#refreshPlaylistListBtn')) { loadPlaylistList(page); }
                    if (target.closest('.delete-playlist-btn')) {
                        const button = target.closest('.delete-playlist-btn');
                        showDeleteConfirm(page, button.getAttribute('data-playlist-id'), button.getAttribute('data-playlist-name'), button);
                    }
                    if (target.closest('.edit-playlist-btn')) {
                        const button = target.closest('.edit-playlist-btn');
                        editPlaylist(page, button.getAttribute('data-playlist-id'));
                    }
                    if (target.closest('#cancelEditBtn')) {
                        cancelEdit(page);
                    }
                });
                
                page.querySelector('#playlistForm').addEventListener('submit', function (e) {
                    e.preventDefault();
                    createPlaylist(page);
                });

                loadConfiguration(page);
            }

            document.addEventListener('pageshow', function (e) {
                const page = e.target;
                if (page.classList.contains('SmartPlaylistConfigurationPage')) {
                    const tabButtons = page.querySelectorAll('.emby-tab-button');
                    const tabContents = page.querySelectorAll('[data-tab-content]');
                    
                    // Only add tab listeners once to prevent duplicates
                    if (!tabListenersInitialized) {
                        tabListenersInitialized = true;
                        tabButtons.forEach(button => {
                            button.addEventListener('click', () => {
                                const tabId = button.getAttribute('data-tab');
                                
                                // Hide any open modals when switching tabs and clean up backdrop listener
                                const modal = page.querySelector('#delete-confirm-modal');
                                if (modal && !modal.classList.contains('hide')) {
                                    modal.classList.add('hide');
                                    // Clean up backdrop listener to prevent memory leak
                                    if (currentModalBackdropHandler) {
                                        modal.removeEventListener('click', currentModalBackdropHandler);
                                        currentModalBackdropHandler = null;
                                    }
                                }
                                
                                tabButtons.forEach(btn => btn.classList.remove('is-active'));
                                button.classList.add('is-active');
                                page.querySelector('#current-tab-title').textContent = button.querySelector('.emby-tab-button-title').textContent;
                                tabContents.forEach(content => {
                                    content.classList.toggle('hide', content.getAttribute('data-tab-content') !== tabId);
                                });
                                if (tabId === 'manage') { loadPlaylistList(page); }
                            });
                        });
                    }
                    
                    const createTab = page.querySelector('.emby-tab-button[data-tab="create"]');
                    if (createTab && !createTab.classList.contains('is-active')) {
                        createTab.click();
                    }
                    initPage(page);
                }
            });
        })();
        </script>
    </div>
</body>
</html> 