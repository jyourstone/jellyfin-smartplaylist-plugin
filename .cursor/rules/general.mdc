---
alwaysApply: true
---

## Code Quality Principles

### DRY (Don't Repeat Yourself)
**Always apply the DRY principle.** When you find duplicated code or logic:
- Extract it into a helper function or utility
- Reuse existing helpers instead of recreating similar functionality
- Prefer creating a new utility over copying and pasting code

Duplicated code leads to:
- Maintenance burden (fixing bugs in multiple places)
- Inconsistencies (forgetting to update all copies)
- Larger codebase with more surface area for bugs

**Example**: If error handling logic is repeated across multiple API calls, extract it into a reusable `extractErrorMessage` utility function.

## Development Environment
Local development is contained in `/dev` directory. Use `./build-local.sh` from `/dev` for builds. Don't modify files outside `/dev` for local testing.

## Codebase Structure

The plugin is organized into the following main directories:

- **`Core/`** - Core business logic and models
  - `Constants/` - MediaTypes, Operators, ResolutionTypes
  - `Enums/` - AutoRefreshMode, RuleLogic, ScheduleTrigger, SmartListType
  - `Models/` - DTOs (SmartListDto, SmartPlaylistDto, SmartCollectionDto, ExpressionSet, OrderDto, Schedule, SortOption)
  - `QueryEngine/` - Rule evaluation engine (Engine, Expression, Factory, FieldDefinitions, Operand, DateUtils)
  - `SmartList.cs` - Main filtering and evaluation class

- **`Api/`** - API layer
  - `Controllers/` - SmartListController (handles both playlists and collections)
  - `Models/` - API-specific models

- **`Services/`** - Service layer with separation between playlists and collections
  - `Abstractions/` - ISmartListService, ISmartListStore interfaces
  - `Playlists/` - PlaylistService, PlaylistStore
  - `Collections/` - CollectionService, CollectionStore
  - `Shared/` - AutoRefreshService, ManualRefreshService, SmartListFileSystem, BasicDirectoryService, AutoRefreshHostedService

- **`Configuration/`** - UI and configuration
  - `config.html` - Main configuration page
  - `config-*.js` - Modular JavaScript files (core, api, lists, rules, filters, etc.)
  - `PluginConfiguration.cs` - Plugin configuration model

- **`Utilities/`** - Helper utilities
  - LibraryManagerHelper, MediaTypeConverter, MediaTypesKey, NameFormatter, ParallelismHelper, RefreshCache, RuntimeCalculator

**Key Classes:**
- `SmartListDto` - Base class for all smart lists (polymorphic with SmartPlaylistDto and SmartCollectionDto)
- `SmartList` - Core filtering engine that processes items based on rules
- `OperandFactory` - Extracts metadata from BaseItem objects
- `SmartListController` - Unified API controller for both playlists and collections

## Code Patterns
Use C# 12+ collection expressions for cleaner code.

## Media Type Constants
Use `Jellyfin.Plugin.SmartLists.Core.Constants.MediaTypes` constants instead of hard-coded strings.

**❌ Don't:** `mediaType == "Episode"`  
**✅ Do:** `mediaType == MediaTypes.Episode`

**Available:** `MediaTypes.Episode`, `MediaTypes.Series`, `MediaTypes.Movie`, `MediaTypes.Audio`, `MediaTypes.MusicVideo`, `MediaTypes.Video`, `MediaTypes.Photo`, `MediaTypes.Book`, `MediaTypes.AudioBook`

## UI Development
When adding form fields, implement across all flows: create form (defaults), edit form (backwards compatibility), display views, API handling, backend DTOs.

Implementation pattern:
- HTML: Add to create/edit sections
- JavaScript: populateStaticSelects() for defaults, edit form loading, form submission, display functions  
- Backend: Update DTOs and validation

JavaScript pattern:
```javascript
// Create defaults
page.querySelector('#newField').value = config.DefaultNewField || 'default';

// Edit with backwards compatibility  
const fieldValue = playlist.NewField !== undefined ? playlist.NewField : 'default';
page.querySelector('#newField').value = fieldValue;

// Form submission
const newFieldValue = page.querySelector('#newField').value;
playlistDto.NewField = newFieldValue;

// Display
const displayValue = playlist.NewField || 'Default';
html += '<strong>New Field:</strong> ' + displayValue + '<br>';
```

## Metadata Extraction Patterns

### Direct Property Access (Cheap Operations)
```csharp
operand.Genres = baseItem.Genres.ToList();
operand.Studios = baseItem.Studios.ToList();
operand.Tags = baseItem.Tags?.ToList() ?? new List<string>();
operand.Name = baseItem.Name;
operand.ProductionYear = baseItem.ProductionYear.GetValueOrDefault();
```

### Library Manager Queries (Expensive Operations)
```csharp
var peopleQuery = new InternalPeopleQuery { ItemId = baseItem.Id };
var getPeopleMethod = libraryManager.GetType().GetMethod("GetPeople", new[] { typeof(InternalPeopleQuery) });
var result = getPeopleMethod.Invoke(libraryManager, new object[] { peopleQuery });
```

### Reflection-Based Discovery
```csharp
var properties = someObject.GetType().GetProperties().Select(p => p.Name).ToArray();
logger?.LogDebug("Available properties: [{Properties}]", string.Join(", ", properties));

var methods = someObject.GetType().GetMethods()
    .Where(m => m.Name.Contains("keyword"))
    .Select(m => m.Name)
    .ToArray();
logger?.LogDebug("Methods containing 'keyword': [{Methods}]", string.Join(", ", methods));
```

## Debugging Workflow
1. Make code changes
2. Build: `./build-local.sh` from `/dev`
3. Wait for user input
4. Check logs: `tail -n 100 jellyfin-data/config/log/log_YYYYMMDD.log`

Log analysis:
```bash
grep -A 10 -B 5 "specific_debug_message" jellyfin-data/config/log/log_*.log
tail -f jellyfin-data/config/log/log_*.log | grep "Smart"
grep -c "expensive_operation" jellyfin-data/config/log/log_*.log
```

Debugging unknown data structures:
```csharp
if (result != null)
{
    logger?.LogDebug("Result type: {Type}", result.GetType().Name);
    
    var properties = result.GetType().GetProperties().Select(p => p.Name).ToArray();
    logger?.LogDebug("Properties: [{Props}]", string.Join(", ", properties));
    
    if (result is IEnumerable<object> enumerable)
    {
        var items = enumerable.Take(3).ToList();
        logger?.LogDebug("Enumerable with {Count} items (showing first 3)", items.Count);
        
        foreach (var item in items)
        {
            var itemProps = item.GetType().GetProperties().Select(p => p.Name).ToArray();
            logger?.LogDebug("Item properties: [{Props}]", string.Join(", ", itemProps));
        }
    }
}
```

## Documentation
The project uses **MkDocs** for documentation, located in the `/docs` folder. When adding new features or making functionality changes that affect users, **always update the documentation** to reflect these changes.

- Documentation structure: `/docs/content/` contains markdown files organized by category
- Configuration: `/docs/mkdocs.yml` defines the documentation structure
- Build and serve locally: Use `mkdocs serve` from the `/docs` directory

## Threading and Thread Safety
Individual lists (playlists and collections) are processed using threading for performance. However, multiple lists are **not** processed simultaneously in parallel.

**Critical:** All code must be **thread-safe**. When working with shared resources, collections, or state:
- Use thread-safe collections (`ConcurrentDictionary`, `ConcurrentBag`, etc.) when needed
- Use proper locking mechanisms (`lock`, `SemaphoreSlim`, etc.) for shared mutable state
- Be aware of race conditions when accessing or modifying shared data
- Consider immutability where possible to avoid threading issues

## Performance Optimization
Two-phase filtering for expensive fields (AudioLanguages, People, AudioQuality, VideoQuality, Collections):
1. Phase 1 (Cheap): Extract basic properties, evaluate non-expensive rules
2. Phase 2 (Expensive): Only for items passing Phase 1, extract expensive data, evaluate complete rules

The two-phase filtering logic is implemented in `Core/SmartList.cs` and uses `MediaTypeExtractionOptions` in `Core/QueryEngine/Factory.cs` to control which expensive fields are extracted.

Adding new expensive fields:
1. Add property to Operand class as `List<string>` or appropriate type
2. Modify `Core/QueryEngine/Factory.cs` with extraction logic in `MediaTypeExtractionOptions` parameter
3. Update `Core/SmartList.cs` filtering with field detection and expensive field condition
4. Add to API in appropriate field category in `Api/Controllers/SmartListController.cs`
5. Update UI in `Configuration/config.html` if collection field

## Jellyfin Data Patterns

### BaseItem Properties (Direct Access)
- Name, ProductionYear, OfficialRating
- Genres, Studios, Tags (collections)
- CommunityRating, CriticRating (may need .GetValueOrDefault())
- DateCreated, DateModified, DateLastRefreshed
- IsPlayed(user) (user-specific)

### Requires Library Manager Queries
- People/Cast/Crew: Use InternalPeopleQuery with ItemId
- Audio/Subtitle streams: Access via MediaSources property or GetMediaStreams() method
- Related items: Use appropriate query objects

### User Data examples (Requires UserDataManager)
- PlayCount, IsFavorite, LastPlayedDate

## Music Fields

**Artists** (track-level) and **AlbumArtists** (album-level) are separate from **People** field (movies/TV only). These are **cheap operations** (simple property access via reflection), not expensive like People (database queries) or AudioLanguages (media stream analysis). They are NOT included in expensive field optimization logic.

## Adding New Sort Options

When adding new sort options to the plugin, you must update **THREE critical locations** in `Core/SmartList.cs` to ensure they work correctly with multiple sorts:

### 1. Create Order Classes (around line 2960+)
Create both Ascending and Descending order classes that inherit from `PropertyOrder<T>`:

```csharp
public class YourNewOrder : PropertyOrder<string>
{
    public override string Name => "YourNew Ascending";
    protected override bool IsDescending => false;
    protected override string GetSortValue(BaseItem item)
    {
        // Extract and return the sort value
        return item.SomeProperty ?? "";
    }
    protected override IComparer<string> Comparer => OrderUtilities.SharedNaturalComparer;
}

public class YourNewOrderDesc : PropertyOrder<string>
{
    public override string Name => "YourNew Descending";
    protected override bool IsDescending => true;
    // Same GetSortValue implementation
}
```

### 2. Add to OrderMap Dictionary (around line 2450)
Register both orders in the `OrderFactory.OrderMap` dictionary:

```csharp
{ "YourNew Ascending", () => new YourNewOrder() },
{ "YourNew Descending", () => new YourNewOrderDesc() },
```

### 3. Add to CreateSortKey Method (around line 1465+) ⚠️ CRITICAL
**This is easy to forget but essential for multiple sorts to work!**

Add a handler in the `CreateSortKey` method to create comparable sort keys:

```csharp
if (order is YourNewOrder || order is YourNewOrderDesc)
{
    return item.SomeProperty ?? "";
}
```

Without this, the multi-sort logic in `ApplyMultipleOrders` cannot create proper sort keys, and secondary/tertiary sorts will be ignored.

### 4. Add to IsDescendingOrder Method (around line 1730)
Add the descending variant to the `IsDescendingOrder` check:

```csharp
order is YourNewOrderDesc ||
```

### Example: SeriesName with "Ignore Articles"
When we added `SeriesName (Ignore Articles)`, we created:
- Classes: `SeriesNameIgnoreArticlesOrder` and `SeriesNameIgnoreArticlesOrderDesc`
- OrderMap entries for both ascending and descending
- CreateSortKey handler that calls `OrderUtilities.StripLeadingArticles(seriesName)`
- IsDescendingOrder entry for the descending variant

**Missing step #3 causes multiple sorts to fail silently** - the first sort works, but secondary sorts are ignored.